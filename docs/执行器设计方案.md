# æ‰§è¡Œå™¨ç²¾ç®€æ–¹æ¡ˆè®¾è®¡å›¾

## 1. æ¨¡å—ç»“æ„å›¾

```mermaid
graph TD
    subgraph Executor["core/executor.rs"]
        run_slot["run_slot(engine, slot_id)<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>æ§½ä½æ‰§è¡Œå…¥å£<br/>éå†æ‰€æœ‰æ­¥éª¤"]
        execute_step["execute_step(slot, step)<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>å•æ­¥éª¤æ‰§è¡Œ<br/>åŒºåˆ†ä¸¤ç§æ¨¡å¼"]
        execute_with_control["execute_with_control(timeout, rx, task)<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>ç»Ÿä¸€å¤„ç†ï¼š<br/>â€¢ è¶…æ—¶<br/>â€¢ æš‚åœ/åœæ­¢ä¿¡å·"]
    end

    subgraph Response["core/response.rs (æ–°å¢)"]
        ResponseProcessor["ResponseProcessor<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>é“¾å¼å¤„ç†ï¼š<br/>raw_data â†’ parse â†’ save â†’ check â†’ result"]
    end

    subgraph Callbacks["core/engine.rs (æ‰©å±•)"]
        call_engine["Callbacks::call_engine_task()<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>å°è£… EngineTaskCallback è°ƒç”¨<br/>å¤„ç† CString è½¬æ¢"]
        call_host["Callbacks::call_host_task()<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>å°è£… HostTaskCallback è°ƒç”¨<br/>å¤„ç† CString è½¬æ¢"]
    end

    run_slot --> execute_step
    execute_step --> execute_with_control
    execute_step --> call_engine
    execute_step --> call_host
    execute_step --> ResponseProcessor
```

---

## 2. ç±»/ç»“æ„ä½“è®¾è®¡

```mermaid
classDiagram
    class run_slot {
        <<å‡½æ•°>>
        +run_slot(engine, slot_id) Result~()~
        éå† test_steps
        è°ƒç”¨ execute_step
        å¤„ç†è·³è½¬é€»è¾‘
    }

    class execute_step {
        <<å‡½æ•°>>
        +execute_step(slot, step, callbacks) StepResult
        if EngineControlled â†’ call_engine_task
        if HostControlled â†’ call_host_task
        ä½¿ç”¨ ResponseProcessor å¤„ç†ç»“æœ
    }

    class execute_with_control {
        <<æ³›å‹å‡½æ•°>>
        +execute_with_control~T~(timeout_ms, control_rx, future) ExecuteResult~T~
        tokio::select! åŒæ—¶ç­‰å¾…:
        - ä»»åŠ¡å®Œæˆ
        - è¶…æ—¶
        - æ§åˆ¶ä¿¡å·
    }

    class ResponseProcessor {
        -data: Vec~u8~
        -parsed: Option~Variable~
        +new(data) Self
        +parse(rule: Option~ParseRule~) Result~Self~
        +save_to(vars, name) Self
        +check(rule, vars) Result~CheckOutput~
        +into_result(step_id, name, elapsed) StepResult
    }

    class ExecuteResult {
        <<æšä¸¾>>
        Completed~T~: ä»»åŠ¡å®Œæˆ
        Timeout: è¶…æ—¶
        Signal~ControlSignal~: æ”¶åˆ°æ§åˆ¶ä¿¡å·
    }

    class Callbacks {
        +call_engine_task(slot_id, task, device) i32
        +call_host_task(slot_id, task) i32
        å†…éƒ¨å¤„ç† CString æŒ‡é’ˆè½¬æ¢
    }
```

---

## 3. æ‰§è¡Œæµç¨‹ï¼ˆEngineControlled æ¨¡å¼ï¼‰

```mermaid
sequenceDiagram
    participant Main as run_slot
    participant Exec as execute_step
    participant Ctrl as execute_with_control
    participant CB as Callbacks
    participant Host as Hostå›è°ƒ
    participant RP as ResponseProcessor

    Main->>Exec: execute_step(step)
    
    Note over Exec: åˆ¤æ–­æ¨¡å¼: EngineControlled
    
    loop å¾ªç¯æ‰§è¡Œ (æœ€å¤š max_iterations æ¬¡)
        Exec->>Ctrl: execute_with_control(timeout, ...)
        Ctrl->>CB: call_engine_task()
        CB->>Host: EngineTaskCallback(...)
        Host-->>CB: è¿”å› 0
        Note over Ctrl: ç­‰å¾… submit_result
        Host->>Ctrl: cat_engine_submit_result(data)
        Ctrl-->>Exec: ExecuteResult::Completed(data)
        
        Exec->>RP: new(data).parse().check()
        RP-->>Exec: CheckOutput
        
        alt æ»¡è¶³ break_condition
            Note over Exec: è·³å‡ºå¾ªç¯
        else ä¸æ»¡è¶³
            Note over Exec: ç­‰å¾… loop_delay_ms
        end
    end
    
    Exec-->>Main: StepResult
```

---

## 4. æ‰§è¡Œæµç¨‹ï¼ˆHostControlled æ¨¡å¼ï¼‰

```mermaid
sequenceDiagram
    participant Main as run_slot
    participant Exec as execute_step
    participant Ctrl as execute_with_control
    participant CB as Callbacks
    participant Host as Hostå›è°ƒ
    participant RP as ResponseProcessor

    Main->>Exec: execute_step(step)
    
    Note over Exec: åˆ¤æ–­æ¨¡å¼: HostControlled
    
    Exec->>Ctrl: execute_with_control(timeout, ...)
    Ctrl->>CB: call_host_task()
    CB->>Host: HostTaskCallback(task_name, params)
    
    Note over Host: Host å†…éƒ¨å®ç°å®Œæ•´é€»è¾‘<br/>åŒ…æ‹¬å¾ªç¯ã€é‡è¯•ã€å¼‚å¸¸å¤„ç†
    
    alt ä»»åŠ¡æˆåŠŸ
        Host->>Ctrl: cat_engine_submit_result(data)
        Ctrl-->>Exec: ExecuteResult::Completed(data)
    else ä»»åŠ¡å¤±è´¥
        Host->>Ctrl: cat_engine_submit_error(msg)
        Ctrl-->>Exec: ExecuteResult::Error(msg)
    else è¶…æ—¶
        Ctrl-->>Exec: ExecuteResult::Timeout
    end
    
    Exec->>RP: new(data).parse().check()
    RP-->>Exec: StepResult
    
    Exec-->>Main: StepResult
```

---

## 5. ResponseProcessor é“¾å¼è°ƒç”¨ç¤ºä¾‹

```mermaid
graph LR
    subgraph è¾“å…¥
        A[raw_data<br/>å­—èŠ‚æ•°ç»„]
    end
    
    subgraph ResponseProcessor
        B[".parse(rule)"] --> C[".save_to(vars, name)"]
        C --> D[".check(rule, vars)"]
        D --> E[".into_result()"]
    end
    
    subgraph è¾“å‡º
        F[StepResult]
    end
    
    A --> B
    E --> F
    
    style B fill:#e1f5fe
    style C fill:#e1f5fe
    style D fill:#e1f5fe
    style E fill:#e1f5fe
```

**ä»£ç ç¤ºä¾‹**ï¼š

```rust
// ä¼ ç»Ÿå†™æ³•ï¼ˆç¹çï¼‰
let parsed = parse_response(&data, &rule)?;
variables.set(&save_to, parsed.clone());
let check_output = execute_check(&check_rule, Some(&parsed), &variables)?;
let result = StepResult::from_check(step_id, step_name, elapsed, check_output);

// é“¾å¼å†™æ³•ï¼ˆæ¸…æ™°ï¼‰
let result = ResponseProcessor::new(data)
    .parse(&step.engine_task.as_ref().and_then(|t| t.parse_rule.as_ref()))?
    .save_to(&mut slot.variables, &step.save_to)
    .check(&step.check_rule, &slot.variables)?
    .into_result(step.step_id, &step.step_name, elapsed);
```

---

## 6. æ–‡ä»¶å˜æ›´æ±‡æ€»

| æ–‡ä»¶ | æ“ä½œ | è¡Œæ•°å˜åŒ– | è¯´æ˜ |
|------|------|---------|------|
| `core/executor.rs` | é‡å†™ | 14 â†’ ~120 | ä¸»æ‰§è¡Œé€»è¾‘ |
| `core/response.rs` | **æ–°å¢** | ~50 | ResponseProcessor |
| `core/engine.rs` | æ‰©å±• | +~40 | Callbacks æ–¹æ³• |
| `core/mod.rs` | ä¿®æ”¹ | +1 | å¯¼å‡º response æ¨¡å— |
| **æ€»è®¡** | | **+~210** | |

---

## 7. å¯¹ç…§åˆ†æï¼šä¸å·²å®Œæˆä»£ç çš„å…¼å®¹æ€§

### âœ… å¯ç›´æ¥å¤ç”¨çš„å·²æœ‰ä»£ç 

| æ¨¡å— | å‡½æ•°/ç»“æ„ | ç”¨é€” |
|------|----------|------|
| `parser/mod.rs` | `parse_response(data, rule)` | è§£æå“åº”æ•°æ® |
| `checker/mod.rs` | `execute_check(rule, value, vars)` | æ‰§è¡Œæ£€æŸ¥è§„åˆ™ |
| `checker/mod.rs` | `CheckOutput` | æ£€æŸ¥ç»“æœç»“æ„ |
| `model/result.rs` | `StepResult::passed/failed/timeout/skipped` | ç»“æœå·¥å‚æ–¹æ³• |
| `model/result.rs` | `CheckResultDetail` | æ£€æŸ¥è¯¦æƒ… |
| `core/slot.rs` | `SlotContext.variables` (VariablePool) | å˜é‡å­˜å– |
| `core/slot.rs` | `ControlSignal` | æ§åˆ¶ä¿¡å·æšä¸¾ |
| `core/engine.rs` | `Callbacks` | å›è°ƒç»“æ„ä½“ |

### âœ… æ— å†²çªï¼Œè®¾è®¡æ–¹æ¡ˆå…¼å®¹

| è®¾è®¡æ–¹æ¡ˆç»„ä»¶ | å·²æœ‰ä»£ç  | å…¼å®¹æ€§ |
|-------------|---------|--------|
| `ResponseProcessor.parse()` | è°ƒç”¨ `parser::parse_response()` | âœ… å¤ç”¨ |
| `ResponseProcessor.check()` | è°ƒç”¨ `checker::execute_check()` | âœ… å¤ç”¨ |
| `ResponseProcessor.into_result()` | ä½¿ç”¨ `StepResult::*()` å·¥å‚æ–¹æ³• | âœ… å¤ç”¨ |
| `Callbacks::call_*()` | æ‰©å±•å·²æœ‰ `Callbacks` ç»“æ„ | âœ… å…¼å®¹ |
| `execute_with_control()` | ä½¿ç”¨ `SlotContext.control_rx` | âœ… å…¼å®¹ |

### ğŸ”„ ResponseProcessor ç®€åŒ–æ–¹æ¡ˆ

åˆ†æåå‘ç°ï¼š`ResponseProcessor` å¯ä»¥è¿›ä¸€æ­¥ç®€åŒ–ï¼

**åŸè®¾è®¡**ï¼š50 è¡Œç‹¬ç«‹ç»“æ„
**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼šæ”¹ä¸º**è¾…åŠ©å‡½æ•°**ï¼Œçº¦ 25 è¡Œ

```rust
// ä¸éœ€è¦å•ç‹¬çš„ structï¼Œç”¨å‡½æ•°å³å¯
fn process_response(
    data: Vec<u8>,
    parse_rule: &Option<ParseRule>,
    save_to: &Option<String>,
    check_rule: &Option<CheckRule>,
    variables: &mut VariablePool,
) -> Result<(Option<Variable>, Option<CheckOutput>)>
```

**åŸå› **ï¼š
1. `parse_response` å’Œ `execute_check` å·²ç»æ˜¯å®Œæ•´å®ç°
2. åªéœ€è¦ä¸€ä¸ªå‡½æ•°ä¸²è”å®ƒä»¬ï¼Œä¸éœ€è¦çŠ¶æ€ç®¡ç†

### ğŸ“‹ æœ€ç»ˆä»£ç å˜æ›´æ¸…å•

| æ–‡ä»¶ | æ“ä½œ | è¡Œæ•° | è¯´æ˜ |
|------|------|------|------|
| `core/executor.rs` | é‡å†™ | ~100 | ä¸»æ‰§è¡Œé€»è¾‘ |
| `core/engine.rs` | +æ–¹æ³• | +30 | `Callbacks::call_*()` |
| `core/mod.rs` | æ— æ”¹åŠ¨ | 0 | ä¸éœ€è¦æ–°æ¨¡å— |
| **æ€»è®¡** | | **~130** | æ¯”åŸè®¡åˆ’å°‘ 80 è¡Œ |

### âœ… ä¸è®¾è®¡æ–‡æ¡£ä¸€è‡´æ€§æ£€æŸ¥

| è®¾è®¡æ–‡æ¡£è¦æ±‚ | å®ç°æ–¹æ¡ˆ | çŠ¶æ€ |
|-------------|---------|------|
| EngineControlled: å¼•æ“æ§åˆ¶å¾ªç¯ | `execute_engine_task()` å†…éƒ¨å¾ªç¯ | âœ… |
| HostControlled: Host æ§åˆ¶å…¨æµç¨‹ | `execute_host_task()` å•æ¬¡è°ƒç”¨ | âœ… |
| è¶…æ—¶å¤„ç† | `tokio::select!` + `timeout_ms` | âœ… |
| æš‚åœ/åœæ­¢ä¿¡å· | `control_rx.recv()` | âœ… |
| æ•°æ®è§£æ | å¤ç”¨ `parser::parse_response()` | âœ… |
| æ£€æŸ¥è§„åˆ™ | å¤ç”¨ `checker::execute_check()` | âœ… |
| å˜é‡å­˜å‚¨ | `slot.variables.set()` | âœ… |
| æ­¥éª¤è·³è½¬ | `next_on_pass/fail/timeout/error` | âœ… |
| UI æ›´æ–° | `Callbacks.ui_update` | âœ… |
