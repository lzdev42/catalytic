# 计算机基础八股文（口语化）

> 🎯 不是让你背，是让你能用自己的话说清楚。

---

## 一、操作系统

### 1. 进程 vs 线程

**一句话**：进程是独立的程序，线程是进程里的执行单元。

> "进程有自己独立的内存空间，互不干扰。线程共享进程的内存，所以线程间通信快，但也容易出并发问题。"

### 2. 死锁

**一句话**：两个线程互相等对方释放资源，谁也动不了。

**四个条件**（记住"互占不循"）：
- **互斥**：资源一次只能一个人用
- **占有等待**：拿着一个资源等另一个
- **不可剥夺**：别人不能抢你的资源
- **循环等待**：A等B，B等A

**怎么避免**：破坏其中一个条件，比如按顺序申请资源（破坏循环等待）。

### 3. 内存管理

**虚拟内存**：让程序觉得自己有很大的连续内存，实际上是映射到物理内存+磁盘。

**页面置换**：内存不够时把不用的页换到磁盘。LRU（最近最少使用）是常见策略。

---

## 二、计算机网络

### 1. TCP vs UDP

| | TCP | UDP |
|---|-----|-----|
| 连接 | 要先建立连接（三次握手） | 不需要连接 |
| 可靠性 | 保证到达、保证顺序 | 不保证 |
| 速度 | 慢一点 | 快 |
| 场景 | 网页、文件传输 | 视频、游戏、DNS |

### 2. 三次握手

> "客户端说'我要连'（SYN），服务端说'好的，我也要连'（SYN+ACK），客户端说'收到，开始吧'（ACK）。"

**为什么是三次不是两次**：防止过期的连接请求突然到达服务端，导致服务端白白等待。

### 3. 四次挥手

> "客户端说'我要断'（FIN），服务端说'收到，等我处理完'（ACK），服务端处理完说'我也断了'（FIN），客户端说'好的'（ACK）。"

**为什么是四次**：因为TCP是全双工，双方都要分别关闭自己的发送通道。

### 4. HTTP vs HTTPS

- **HTTP**：明文传输，不安全
- **HTTPS**：HTTP + SSL/TLS加密，安全

### 5. HTTP状态码

- **2xx**：成功（200 OK）
- **3xx**：重定向（301永久移动，302临时移动）
- **4xx**：客户端错误（404找不到，403禁止）
- **5xx**：服务端错误（500内部错误，502网关错误）

---

## 三、数据结构

### 1. 数组 vs 链表

| | 数组 | 链表 |
|---|------|------|
| 内存 | 连续 | 分散 |
| 随机访问 | O(1) | O(n) |
| 插入删除 | O(n) | O(1)（如果有指针） |
| 场景 | 读多写少 | 写多读少 |

### 2. 栈 vs 队列

- **栈**：后进先出（LIFO），像弹夹
- **队列**：先进先出（FIFO），像排队

### 3. 哈希表

**原理**：通过哈希函数把key映射到数组下标，查找是O(1)。

**冲突解决**：
- 链表法：同一个位置用链表存多个
- 开放寻址：冲突了就往后找空位

### 4. 树

- **二叉树**：每个节点最多两个子节点
- **二叉搜索树（BST）**：左子树都比根小，右子树都比根大
- **平衡树**：保证左右子树高度差不大，查找是O(log n)
- **红黑树**：一种平衡树，Java的TreeMap用的就是这个

### 5. 图

- **DFS**：深度优先，一条路走到黑再回头
- **BFS**：广度优先，一层一层扩展

---

## 四、算法

### 1. 时间复杂度

- **O(1)**：常数时间，不管数据多大都一样快
- **O(log n)**：二分查找
- **O(n)**：遍历一遍
- **O(n log n)**：好的排序算法（快排、归并）
- **O(n²)**：嵌套循环（冒泡排序）

### 2. 排序算法

| 算法 | 时间复杂度 | 稳定性 | 特点 |
|------|-----------|--------|------|
| 冒泡 | O(n²) | 稳定 | 简单但慢 |
| 快排 | O(n log n) | 不稳定 | 实际最常用 |
| 归并 | O(n log n) | 稳定 | 需要额外空间 |
| 堆排 | O(n log n) | 不稳定 | 原地排序 |

### 3. 二分查找

**前提**：数组有序

**思路**：每次取中间，比较后排除一半

```
left, right = 0, n-1
while left <= right:
    mid = (left + right) / 2
    if arr[mid] == target: return mid
    elif arr[mid] < target: left = mid + 1
    else: right = mid - 1
```

### 4. 动态规划

**一句话**：大问题拆成小问题，记住小问题的答案避免重复计算。

**经典例子**：斐波那契、背包问题、最长公共子序列

---

## 五、数据库

### 1. SQL vs NoSQL

| | SQL | NoSQL |
|---|-----|-------|
| 结构 | 固定表结构 | 灵活文档/键值 |
| 场景 | 关系复杂、事务要求高 | 海量数据、快速迭代 |
| 代表 | MySQL、PostgreSQL | MongoDB、Redis |

### 2. 事务 ACID

- **A 原子性**：要么全做，要么全不做
- **C 一致性**：数据从一个正确状态到另一个正确状态
- **I 隔离性**：并发事务互不干扰
- **D 持久性**：提交了就永久保存

### 3. 索引

**原理**：像书的目录，快速定位数据。

**B+树索引**：大多数数据库用的，适合范围查询。

**什么时候建索引**：经常查询、经常排序、经常做连接条件的列。

### 4. SQL注入

**问题**：用户输入被当成SQL执行。

**防御**：用参数化查询，不要拼接字符串。

---

## 六、设计模式（常问的几个）

### 1. 单例

**目的**：全局只有一个实例。

**实现**：私有构造函数 + 静态方法获取实例。

### 2. 工厂

**目的**：把对象创建逻辑封装起来，调用方不关心具体类型。

### 3. 观察者

**目的**：一对多通知，一个对象变化，通知所有订阅者。

**例子**：事件监听、发布订阅。

### 4. 策略

**目的**：把算法封装成独立类，可以互换。

**例子**：支付方式（微信/支付宝/银行卡）。

---

## 快速自测

能用自己的话说清楚吗？

- [ ] 进程和线程的区别
- [ ] TCP三次握手为什么是三次
- [ ] 数组和链表怎么选
- [ ] 什么时候用哈希表
- [ ] 快排的时间复杂度
- [ ] 什么是事务的ACID
- [ ] 怎么防SQL注入
