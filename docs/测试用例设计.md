# 真实场景测试用例设计

## 场景背景

一个射频模块生产测试工位，需要测试以下内容：
- **电压检测**：模块供电电压是否正常
- **电流检测**：模块工作电流是否在规格范围
- **射频信号**：发射功率、频率是否合规

---

## 一、仪器配置

### 1.1 万用表（DMM）

| 属性 | 值 |
|------|---|
| 标签 | DMM_1 |
| 协议 | VISA (SCPI) |
| 地址 | TCPIP0::192.168.1.101::INSTR |

**常用 SCPI 指令**：

| 功能 | 指令 | 返回示例 |
|------|------|---------|
| 识别 | `*IDN?` | `Agilent,34401A,0,...` |
| 测直流电压 | `MEAS:VOLT:DC?` | `3.315` |
| 测直流电流 | `MEAS:CURR:DC?` | `0.125` |
| 测交流电压 | `MEAS:VOLT:AC?` | `0.002` |

---

### 1.2 频谱分析仪（Spectrum Analyzer）

| 属性 | 值 |
|------|---|
| 标签 | SA_1 |
| 协议 | VISA (SCPI) |
| 地址 | TCPIP0::192.168.1.102::INSTR |

**常用 SCPI 指令**：

| 功能 | 指令 | 返回示例 |
|------|------|---------|
| 识别 | `*IDN?` | `Rohde&Schwarz,FSV,1312.8000,...` |
| 设置中心频率 | `FREQ:CENT 2.4GHz` | (无返回) |
| 设置 Span | `FREQ:SPAN 10MHz` | (无返回) |
| 读取峰值功率 | `CALC:MARK:MAX;:CALC:MARK:Y?` | `-10.5` |
| 读取峰值频率 | `CALC:MARK:X?` | `2400123456` |

---

## 二、测试流程（5 步）

### 步骤 1：检测供电电压

| 配置项 | 值 |
|-------|---|
| 步骤ID | 1 |
| 步骤名 | 检测供电电压 |
| 模式 | EngineControlled |
| 目标设备 | dmm |
| 指令 | `MEAS:VOLT:DC?` |
| 解析规则 | Number（提取数字） |
| 存储变量 | `supply_voltage` |
| 检查规则 | RangeCheck: 3.2V ~ 3.4V |
| 成功跳转 | 步骤 2 |
| 失败跳转 | 结束（报错） |

---

### 步骤 2：检测工作电流

| 配置项 | 值 |
|-------|---|
| 步骤ID | 2 |
| 步骤名 | 检测工作电流 |
| 模式 | EngineControlled |
| 目标设备 | dmm |
| 指令 | `MEAS:CURR:DC?` |
| 解析规则 | Number |
| 存储变量 | `work_current` |
| 检查规则 | Threshold: < 0.3A |
| 成功跳转 | 步骤 3 |
| 失败跳转 | 结束（报错） |

---

### 步骤 3：设置频谱仪参数

| 配置项 | 值 |
|-------|---|
| 步骤ID | 3 |
| 步骤名 | 配置频谱仪 |
| 模式 | EngineControlled |
| 目标设备 | sa |
| 指令 | `FREQ:CENT 2.4GHz;FREQ:SPAN 10MHz` |
| 解析规则 | 无（发送指令不读取） |
| 检查规则 | 无 |
| 成功跳转 | 步骤 4 |

---

### 步骤 4：测量射频功率

| 配置项 | 值 |
|-------|---|
| 步骤ID | 4 |
| 步骤名 | 测量射频功率 |
| 模式 | EngineControlled |
| 目标设备 | sa |
| 指令 | `CALC:MARK:MAX;:CALC:MARK:Y?` |
| 解析规则 | Number |
| 存储变量 | `rf_power_dbm` |
| 检查规则 | RangeCheck: -15dBm ~ -5dBm |
| 成功跳转 | 步骤 5 |
| 失败跳转 | 结束（报错） |

---

### 步骤 5：验证射频频率

| 配置项 | 值 |
|-------|---|
| 步骤ID | 5 |
| 步骤名 | 验证射频频率 |
| 模式 | EngineControlled |
| 目标设备 | sa |
| 指令 | `CALC:MARK:X?` |
| 解析规则 | Number |
| 存储变量 | `rf_freq_hz` |
| 检查规则 | RangeCheck: 2.4GHz ± 100kHz (2399900000 ~ 2400100000) |
| 成功跳转 | 结束（成功） |
| 失败跳转 | 结束（报错） |

---

## 三、测试用例清单

### A. 配置管理测试

| 用例ID | 名称 | 操作 |
|-------|------|------|
| A1 | 添加仪器 | 添加 DMM_1 和 SA_1 两个设备 |
| A2 | 添加测试流程 | 添加上述 5 个步骤 |
| A3 | 修改步骤参数 | 将步骤 1 的电压范围从 3.2~3.4 改为 3.0~3.6 |
| A4 | 调整步骤顺序 | 将步骤 3 移到步骤 4 之后（先测功率再配置） |
| A5 | 删除步骤 | 删除步骤 5（频率验证） |
| A6 | 槽位绑定 | 将 slot 0 绑定 DMM_1 和 SA_1 |

---

### B. 执行测试

| 用例ID | 名称 | 模拟场景 |
|-------|------|---------|
| B1 | 正常通过 | Host 返回正常数据，所有检查通过 |
| B2 | 电压超出范围 | Host 返回 2.8V，验证跳转到失败 |
| B3 | 设备超时 | Host 不调用 submit_result，验证超时处理 |
| B4 | 多槽位并行 | 同时启动 slot 0 和 slot 1 |
| B5 | 中途暂停/恢复 | 执行到步骤 2 时暂停，等待后恢复 |

---

## 四、Mock Host 行为

在 Rust 测试中，我们使用回调模拟 Host 行为：

```rust
extern "C" fn mock_engine_callback(
    slot_id: u32, task_id: u64, device_type: *const c_char,
    ..., payload: *const u8, payload_len: u32, ...
) -> i32 {
    // 1. 解析指令
    let cmd = String::from_utf8_lossy(slice::from_raw_parts(payload, payload_len));
    
    // 2. 根据指令返回模拟数据
    let response = match cmd.as_ref() {
        "MEAS:VOLT:DC?" => "3.32",
        "MEAS:CURR:DC?" => "0.125",
        "CALC:MARK:MAX;:CALC:MARK:Y?" => "-10.5",
        "CALC:MARK:X?" => "2400050000",
        _ => "",
    };
    
    // 3. 异步提交结果
    std::thread::spawn(move || {
        std::thread::sleep(Duration::from_millis(50));
        cat_engine_submit_result(engine, slot_id, task_id, response.as_ptr(), response.len());
    });
    
    0  // 返回成功
}
```

---

## 五、预期验证点

| 验证项 | 方法 |
|-------|------|
| 仪器已添加 | `engine.get_device_type("dmm")` 返回非 None |
| 步骤已添加 | `engine.get_test_steps().len() == 5` |
| 变量已存储 | `slot.variables.get("supply_voltage")` 返回 3.32 |
| 检查结果正确 | `step_results[0].check_result.passed == true` |
| 状态更新正确 | `slot.status() == SlotStatus::Completed` |
| 跳转逻辑正确 | 失败时 `step_results.len() < 5` |

---

## 确认问题

1. 这个场景是否贴近你的真实使用？
2. 需要增加/调整仪器类型吗（如示波器、信号源）？
3. 检查规则设计是否合理？
4. 需要加入 HostControlled 模式的步骤吗（如"等待设备预热"）？
